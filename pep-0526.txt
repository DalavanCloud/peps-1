PEP: 526
Title: Syntax for Variable and Attribute Annotations
Version: $Revision$
Last-Modified: $Date$
Author: Ryan Gonzalez <rymg19@gmail.com>, Philip House <phouse512@gmail.com>, Guido van Rossum <guido@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 09-Aug-2016
Python-Version: 3.6


Notice for Reviewers
====================

This PEP is not ready for review.  We're merely committing changes
frequently so we don't end up with a huge merge conflict.  For minor
textual nits please use https://github.com/python/peps/ssues and
"at-mention" at least one of the authors.  For discussion about
contents, please refer to https://github.com/python/typing/issues/258.


Abstract
========

PEP 484 introduced type hints, a.k.a. type annotations.  While its
main focus was function annotations, it also introduced the notion of
type comments to annotate variables::

  # 'primes' is a list of integers
  primes = []  # type: List[int]

  # 'captain' is a string (Note: initial value is a problem)
  captain = ...  # type: str

  class Starship:
      # 'stats' is a class attribute
      stats = {}  # type: Dict[str, int]

This PEP aims at adding syntax to Python for annotating the types of variables
and attributes, instead of expressing them through comments::

  primes: List[int] = []

  captain: str  # Note: no initial value!

  class Starship:
      stats: ClassVar[Dict[str, int]] = {}


Rationale
=========

Although type comments work well, the fact that they're expressed through
comments has some downsides:

- Text editors often highlight comments differently from type annotations.
- There isn't a way to annotate the type of an undefined variable; you need to
  initialize it to ``None`` (e.g. ``a = None # type: int``).
- Variables annotated in a conditional branch are difficult to read::

    if some_value:
        my_var = function() # type: Logger
    else:
        my_var = another_function() # Why isn't there a type here?

- Since type comments aren't actually part of the language, if a Python script
  wants to parse them, it would require a custom parser instead of just using
  ``ast``.
- Type comments are used a lot in typeshed. Migrating typeshed to use
  the variable annotation syntax instead of type comments would improve
  readability of stubs.
- In situations where normal comments and type comments used together, it is
  difficult to distinguish them::

    path = None  # type: Optional[str]  # Path to module source

- It's impossible to retrieve the annotations at runtime outside of
  attempting to find the module's source code and parse it at runtime,
  which is inelegant, to say the least.

The majority of these issues can be alleviated by making the syntax
a core part of the language.

Non-goals
*********

While the proposal is accompanied by an addition of ``inspect.getannotations``
standard library function for runtime retrieval of annotations, the variable
annotations are not designed for runtime type checking. Third party packages
would have to be developed to implement such functionality.

It should also be emphasized that **Python will remain a dynamically typed
language, and the authors have no desire to ever make type hints mandatory,
even by convention.** The goal of annotation syntax is to provide an
easy way to specify the structured type metadata for third party tools.


Specification
=============

*** big key concepts, not quite sure what the best way to organize this would
be, or if they deserve their own sections ***

Variable Annotations
********************

The types of locals and globals can be annotated as follows::

  some_number: int           # variable without default
  some_list: List[int] = []  # variable with default

Being able to omit the initial value allows for easier typing of variables
assigned in conditional branches::

  sane_world: bool
  if 2+2 == 4:
      sane_world = True
  else:
      sane_world = False

Note that, although this syntax does allow tuple packing, it does *not* allow
one to annotate the types of variables when tuple unpacking is used::

  # Tuple packing with variable annotation syntax
  t: Tuple[int, ...] = (1, 2, 3)

  # Tuple unpacking with variable annotation syntax
  header: str
  kind: int
  body: Optional[List[str]]
  header, kind, body = message

Omitting a default value leaves the variable uninitialized::

  a: int
  print(a)  # raises NameError

However, annotating a local variable will cause the interpreter to always make
it a local::

  def f():
      a: int
      print(a)  # raises UnboundLocalError
      # Commenting out the ``a: int`` makes it a NameError!

as if the code were::

  def f():
      if False: a = 0
      print(a)  # raises UnboundLocalError

Any duplicate type annotations will be ignored. Although static type
checkers will issue a warning for annotations of the same variable
by a different type::

  a: int
  a: str  # Static type checker will warn about this.

Attribute annotations
*********************

Type annotations can be used to also annotate attributes
in class bodies. In particular, the value-less notation ``a: int`` allows us
to annotate instance variables that should be initialized in ``__init__``
or ``__new__``. The proposed syntax is as follows::

  class BasicStarship:
      captain: str = 'Picard'               # instance variable with default
      damage: int                           # instance variable without default
      stats: ClassVar[Dict[str, int]] = {} # class variable

Here ``ClassVar`` is a special class in typing module that indicates to
static type checker that this attribute should not be set on class instances.
This could be illustrated with a more detailed example. In this class::

  class Starship:
      captain = 'Picard'
      stats = {}
      def __init__(self, damage, captain=None):
          self.damage = damage
          if captain:
              self.captain = captain  # Else keep the default
      def hit(self):
          Starship.stats['hits'] = Starship.stats.get('hits', 0) + 1

``stats`` is intended to be a class variable (keeping track of many different
per-game statistics), while ``captain`` is an instance variable with a default
value set in the class. This difference could not be seen by type
checker -- both get initialized in the class, but ``captain`` serves only
as a convenient default value for the instance variable, while ``stats``
is truly a class variable -- it is intended to be shared by all instances.

Since both variables happen to be initialized at the class level, it is
useful to distinguish them by marking class variables as annotated with
types wrapped in ``ClassVar[...]``. In such way type checker will prevent
accidental assignments to attributes with a same name on class instances.
For example, annotating the discussed class::

  class Starship:
      captain: str = 'Picard'
      damage: int
      stats: ClassVar[Dict[str, int]] = {}
      def __init__(self, damage: int, captain: str = None):
          self.damage = damage
          if captain:
              self.captain = captain  # Else keep the default
      def hit(self):
          Starship.stats['hits'] = Starship.stats.get('hits', 0) + 1

      enterprise_d = Starship(3000)
      enterprise_d.stats = {} # Flagged as error by a type checker
      Starship.stats = {} # This is OK

As a matter of convenience, instance attributes can be annotated in
``__init__`` or other methods, rather than in class::

  from typing import Generic, TypeVar
  T = TypeVar(’T’)

  class Box(Generic[T]):
      def __init__(self, content):
          self.content: T = content

Where annotations aren't allowed
********************************

It's illegal to attempt to annotate ``global`` and ``nonlocal``::

  def f():
      global x: int  # SyntaxError

The reason is that ``global`` and ``nonlocal`` don't own variables;
therefore, the type annotations belong in the scope owning the variable.

In addition, you cannot annotate variable used in a ``for`` or ``with``
statement; they can be annotated ahead of time, in a similar manner to tuple
unpacking::

  a: int
  f: MyFile
  for a in my_iter:
      with myfunc() as f:
          ...


Changes to standard library and documentation
=============================================

- Special covariant type ``ClassVar[T_co]`` is added to the ``typing``
  module. It accepts only a single argument that should be a valid type,
  and is used to annotate class variables that should no be set on class
  instances. This restriction is ensured by static checkers,
  but not at runtime.

- Function ``getannotaions`` is added to the ``inspect`` module that is used
  to retrieve annotations at runtime from modules, classes, and functions.
  Annotations are returned as a dictionary mapping from variable, arguments,
  or attributes to their type hints. For classes it returns
  ``collections.ChainMap`` constructed from annotations in method
  resolution order of that class.

- Recommended guidelines for using annotations will be added to the
  documentation, containing a pedagogical recapitulation of specifications
  described in this PEP and in PEP 484. As well, a helper script for
  translating type comments into type annotations will be published
  separately from the standard library.


Runtime effects of type annotations
===================================

Variable annotations that are found at a module or class level are
evaluated and stored in ``__annotations__`` attribute of that module or
class as a dictionary mapping from names to evaluated annotations.
Here is an example::

  from typing import Dict
  class Player:
      ...
  players: Dict[str, Player]

  print(__annotations__)
  # prints: {'players': typing.Dict[str, __main__.Player]}

The recommended way of getting annotations at runtime is by using
``inspect.getannotations`` function; as with all dunder attributes,
any undocummented use of ``__annotations__`` is subject to breakage
without warning::

  from typing import Dict, ClassVar
  from inspect import getannotations
  class Starship:
      hitpoints: int = 50
      stats: ClassVar[Dict[str, int]] = {}
      shield: int = 100
      captain: str
      def __init__(self, captain: str) -> None:
          ...

  assert getannotations(Starship) == {'hitpoints': int,
                                      'stats': ClassVar[Dict[str, int]],
                                      'shield': int,
                                      'captain': str}

  assert getannotations(Starship.__init__) == {'captain': str,
                                               'return': None}

Note that if annotations are not found statically, then the
``__annotations__`` dictionary is not created at all. Also the
value of having annotations available locally does not offset
the cost of having to create and populate the annotations dictionary
on every function call. Therefore annotations at function level are
not evaluated and not stored.

Other uses of annotations
*************************

While Python with this PEP will not object to::

  alice: 'well done' = 'A+'
  bob: 'what a shame' = 'F-'

since it will not care about the type annotation beyond "it evaluates
without raising", a type checker that encounters it will flag it,
unless disabled with ``# type: ignore`` or ``@no_type_check``.

However, since Python won't care what the "type" is,
if the above snippet is at the global level or in a class, ``__annotations__``
will include ``{'alice': 'well done', 'bob': 'what a shame'}``.

These stored annotations might be used for other purposes,
but with this PEP we explicitly recommend type hinting as the
preferred use of annotations.


Rejected proposals and things left out for now
=============================================

- **Introduce a new keyword:**
  First, choice of a good keyword is hard,
  e.g. it can't be ``var`` because that is way too common a variable name,
  and it can't be ``local`` if we want to use it for class variables or
  globals. Second, no matter what we choose, we'll still need
  a ``__future__`` import.

- **Allow type annotations for tuple unpacking:**
  This cause an ambiguity: PEP 484 says that everywhere, where a type
  is expected but missing ``Any`` is assumed. Therefore it is
  not clear what meaning should be assigned to this statement::

    x, y: T

  This could mean both ``x`` is of type ``Any``, ``y`` is of type ``T``,
  and ``x`` and ``y`` have tpe ``T``, whatever choice we made this will
  lead to confusions.

- **Parenthesized form ``(var: type)`` for annotations:**
  It was brought up on python-ideas as a remedy for above mentioned
  ambiguity, but it was rejected since such syntax will be hairy,
  the benefits are slight, and the readability would be poor.

- **Allow annotations in chained assignments:**
  This has problems of ambiguity and readability similar to tuple
  unpacking, for example in::

    x: int = y = 1
    z = w: int = 1

  it is ambiguous, what should be the type of ``y``, and what should
  be the type of ``z``. Also the second line is difficult to parse.

- **Allow annotations in ``with`` and ``for`` statement:**
  This was rejected because in ``for`` it makes hard to spot the actual
  iterable, and in ``with`` it will confuse the CPython's LL(1) parser.

- **Allow annotations of complex expressions:**
  This creates a problem with evaluation of the left hand side:
  On one hand, if that expression is going to be evaluated,
  then it leads to inconsistency: ``f().a: int``
  calls ``f()``, but, e.g., ``d[f()]: int`` cannot call ``f()``
  since it can't call ``d.__setitem__()`` without an actual item.
  On other hand, if the left hand side is not evaluated
  (so in the first and second example ``f()`` should not be called),
  then some bugs will not be caught at runtime.
  Finally, the main intention of annotations is to annotate variables
  and attributes in modules and classes, and two forms ``x: int`` and
  ``self.x: int`` are enough for this purpose.

- **Store variable annotations also in function scope:**
  The value of having the annotations available locally is just not enough
  to significantly offset the cost of creating and populating the dictionary
  on *each* function call.

- **Initialize variables annotated without assignment:**
  It was proposed on python-ideas to initialize ``x`` in ``x: int`` to
  ``None`` or to an additional special constant like Javascript's
  ``undefined``. However, adding yet another singleton value to the language
  will be needed to checked for everywhere in the code. Also,
  Guido just said plain "No" to this.

- **Add also** ``InstanceAttr`` **to the typing module:**
  This is redundant because instance variables are way more common than
  class variables. The more common usage deserves to be the default.

- **Allow instance attribute annotations only in methods:**
  The problem is that many ``__init__`` methods do a lot of things besides
  initializing instance variables, and it would be harder (for a human)
  to find all the instance variable declarations.
  And sometimes ``__init__`` is factored into more helper methods
  so it's even harder to chase them down. Putting the instance variable
  declarations together in the class makes it easier to find them,
  and helps a first-time reader of the code.

- **Forget about** ``ClassVar`` **altogether:**
  This was proposed since mypy seems to be getting along fine without a way
  to distinguish between class and instance variables. But a type checker
  can do useful things with the extra information, for example flag
  accidental assignments to a class variable via the instance
  which creates an instance variable shadowing the class variable.
  It could also flag instance variables with mutable defaults,
  a well-known hazard.

- **Do not evaluate annotations, treat them as strings:**
  This is inconsistent with the behavior of function annotations that
  are always evaluated. Although this might be reconsidered in future,
  it was decided in PEP 484 that this will be a separate PEP.

- **Declare attribute types in class docstring:**
  Many projects already use various docstring conventions, often without
  much consistency and generally without conforming to the PEP 484 annotation
  syntax yet. Also this will require a special sophisticated parser.
  This, in turn, defeats the purpose of the PEP --
  collaborating with the third party type checking tools.


Backwards Compatibility
=======================

This PEP is fully backwards compatible.


Implementation
==============

An implementation for Python 3.6 is found on GitHub repo at
https://github.com/ilevkivskyi/cpython/tree/pep-526


Copyright
=========

This document has been placed in the public domain.
