PEP: 526
Title: Variable Declaration Syntax
Version: $Revision$
Last-Modified: $Date$
Author: Ryan Gonzalez <rymg19@gmail.com>, Philip House <phouse512@gmail.com>, Guido van Rossum <guido@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 09-Aug-2016
Python-Version: 3.6

Abstract
========

PEP 484 introduced type hints and; In particular, it introduced the notion of
type comments::

  # a is specified to be a list of ints.
  a = []  # type: List[int]
  # b is a string
  b = None  # type: str
  class Cls:
    my_class_attr = True  # type: bool

This PEP aims at adding syntax to Python for declaring the types of variables and
attributes, instead of expressing them through comments::

  a: List[int] = []
  b: str
  class Cls:
    my_class_attr: ClassAttr[bool] = True

Rationale
=========

Although type comments work well, the fact that they're expressed through
comments has some downsides:

- Text editors often highlight comments differently from type declarations.
- There isn't a way to declare the type of an undefined variable; you need to
  initialize it to ``None`` (e.g. ``a = None # type: int``).
- Variables declared in a conditional branch are difficult to read::

    if some_value:
        my_var = function() # type: Logger
    else:
        my_var = another_function() # Why isn't there a type here?

- Since type comments aren't actually part of the language, if a Python script
  wants to parse them, it would require a custom parser instead of just using
  ``ast``.
- It's impossible to retrieve the annotations at runtime outside of attempting to
  find the module's source code and parse it at runtime, which is inelegant, to
  say the least.

The majority of these issues can be alleviated by making the syntax a core part of
the language.

Specification
=============

*** big key concepts, not quite sure what the best way to organize this would be,
or if they deserve their own sections ***

- Class Variable Typing

Adding variable types allow for us declare the types of instance variables in class
bodies. In particular, the value-less notation (`a: int`) allows us to declare 
instance variables that should be initialized in `__init__` or `__new__`. The
proposed syntax looks as follows::

  class Starship:
      captain: str                      # instance variable without default
      damage: int = 0                   # instance variable with default
      stats: class Dict[str, int] = {}  # class variable with initialization
  
- Capturing Types at Runtime

In order to capture variable types that are usable at runtime, we store the 
types in `__annotations__` as dictionaries at various levels. At each level (for
example, global), the types dictionary would be stored in the `__annotations__`
dictionary for that given level. Here is an example for both global and class 
level types::

  # print global type declarations
  players: Dict[str, Player]
  print(__annotations__)

  # print class type declarations
  class Starship:
    hitpoints: class int = 50
    stats: class Dict[str, int] = {}
    shield: int = 100
    captain: str  # no initial value
  print(Starship.__annotations__)

A note about locals -- the value of having annotations available locally does not
offset the cost of having to create and populate the annotations dictionary on
every function call.

These annotations would be printed out from the previous program as follows::
  {'players': Dict[str, Player]}

  {'hitpoints': ClassVar[int],
   'stats': ClassVar[Dict[str, int]],
   'shield': int,
   'captain': str
  }



Backwards Compatibility
=======================


Copyright
=========

This document has been placed in the public domain.
